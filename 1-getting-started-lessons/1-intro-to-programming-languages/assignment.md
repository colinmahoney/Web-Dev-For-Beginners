# Reading the Docs

## Instructions

There are many tools that a web developer may need that are on the [MDN documentation for client-side tooling](https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Understanding_client-side_tools/Overview). Select 3 tools not covered in the lesson, explain why a web developer would use it, and search for a tool that falls under this category and share its documentation. Do not use the same tool example on MDN docs.

## Rubric

Exemplary | Adequate | Needs Improvement
--- | --- | -- |
|Explained why web developer would use tool| Explained how, but not why developer would use tool| Did not mention how or why a developer would use tool  |

### Client-Side Tool Categories
- Safety Net
  - Linters
  - Source Code Control
  - Code Formatters
  - Bundlers/Packagers
- Transformation
- Post-Development
  - Testing Tools
  - Deployment Tools

#### Standard
github.com/standard/standard

Standard is a JavaScript style guide, linter, and formatter tool. Standard can be used to check for code errors and to ensure that JavaScript code conforms to the 'standard' formating. Standard is simlar to ESLint, but Standard includes a pre-defined set of rules and ESLint allows the rules to be customized. 

#### Electron Packager
https://github.com/electron/electron-packager

Electron Packager is a tool that packages application source code with other files that are necessary to support the code on different host platforms. Electron is a framework which makes it possible to build desktop application using JavaScript. One application, written using Electron, can be packaged with helper files for different operating systems. Electron Packager automates the process of packaging your code with the proper helper files for each platform.

#### husky
https://github.com/okonet/lint-staged

Husky is a tool that allows a programmer to create a trigger to automate the running of another tool when a file is committed or pushed to a Git repository. For instance, Husky can be configured to run a linter on your code every time changes are committed. This not only ensures that the linter is always run before code is committed to the repo, but it also saves the programmer time by automating the process.


